# This workflow should be placed in the PUBLIC repository: jktech-training/skill-matrix-deploy
# File: .github/workflows/deploy.yml

name: Deploy Frontend and Backend

on:
  repository_dispatch:
    types: [trigger-from-private]

jobs:
  setup:
    runs-on: ubuntu-latest
    outputs:
      deploy_frontend: ${{ steps.env.outputs.deploy_frontend }}
      deploy_backend: ${{ steps.env.outputs.deploy_backend }}
      repo: ${{ steps.env.outputs.repo }}
      branch: ${{ steps.env.outputs.branch }}
      env: ${{ steps.env.outputs.env }}
      env_prefix: ${{ steps.env.outputs.env_prefix }}
      cloud_run_service: ${{ steps.env.outputs.cloud_run_service }}
      image_suffix: ${{ steps.env.outputs.image_suffix }}
      bucket_name: ${{ steps.env.outputs.bucket_name }}

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          repository: ${{ github.event.client_payload.repository || 'jktech-training/skill-matrix-V2' }}
          ref: ${{ github.event.client_payload.ref || 'main' }}
          token: ${{ secrets.PRIVATETOKENPULL }}

      - name: Determine Environment
        id: env
        run: |
          BRANCH=${{ github.event.client_payload.ref || 'main' }}
          REPO=${{ github.event.client_payload.repository || 'jktech-training/skill-matrix-V2' }}
          DEPLOYMENT_TYPE=${{ github.event.client_payload.deployment_type || 'full' }}
          
          # Determine deployment targets
          case "$DEPLOYMENT_TYPE" in
            frontend) DEPLOY_BACKEND="false"; DEPLOY_FRONTEND="true" ;;
            backend) DEPLOY_BACKEND="true"; DEPLOY_FRONTEND="false" ;;
            *) DEPLOY_BACKEND="true"; DEPLOY_FRONTEND="true" ;;
          esac
          
          # Determine repository identifier
          [[ "$REPO" == *"skill-matrix-V2"* ]] && REPO_ID="skill-matrix-V2" || REPO_ID="skill-matrix"
          
          # Set environment variables
          if [[ "$BRANCH" == "main" ]]; then
            ENV="production"
            ENV_PREFIX=""
            CLOUD_RUN_SERVICE="$REPO_ID"
            IMAGE_SUFFIX=""
            BUCKET_NAME="skill_matrix"
          else
            ENV="development"
            ENV_PREFIX="dev_"
            CLOUD_RUN_SERVICE="${REPO_ID}-dev"
            IMAGE_SUFFIX="-dev"
            BUCKET_NAME="dev_skill_matrix"
          fi
          
          CLOUD_RUN_SERVICE=$(echo "$CLOUD_RUN_SERVICE" | tr '[:upper:]' '[:lower:]')
          
          echo "repo=$REPO" >> $GITHUB_OUTPUT
          echo "branch=$BRANCH" >> $GITHUB_OUTPUT
          echo "env=$ENV" >> $GITHUB_OUTPUT
          echo "env_prefix=$ENV_PREFIX" >> $GITHUB_OUTPUT
          echo "cloud_run_service=$CLOUD_RUN_SERVICE" >> $GITHUB_OUTPUT
          echo "image_suffix=$IMAGE_SUFFIX" >> $GITHUB_OUTPUT
          echo "bucket_name=$BUCKET_NAME" >> $GITHUB_OUTPUT
          echo "deploy_frontend=$DEPLOY_FRONTEND" >> $GITHUB_OUTPUT
          echo "deploy_backend=$DEPLOY_BACKEND" >> $GITHUB_OUTPUT

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          credentials_json: '${{ secrets.GCP_SAKEY }}'

      - name: Set up Google Cloud SDK
        uses: google-github-actions/setup-gcloud@v2
        with:
          project_id: training-project-419308

  deploy-frontend:
    runs-on: ubuntu-latest
    needs: setup
    if: needs.setup.outputs.deploy_frontend == 'true'

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          repository: ${{ github.event.client_payload.repository || 'jktech-training/skill-matrix-V2' }}
          ref: ${{ github.event.client_payload.ref || 'main' }}
          token: ${{ secrets.PRIVATETOKENPULL }}

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          credentials_json: '${{ secrets.GCP_SAKEY }}'

      - name: Set up Google Cloud SDK
        uses: google-github-actions/setup-gcloud@v2
        with:
          project_id: training-project-419308

      - name: Check for Changes in Frontend
        id: check_frontend
        run: |
          set -euo pipefail
          git fetch --unshallow --tags 2>/dev/null || git fetch --tags || true
          
          BRANCH="${{ needs.setup.outputs.branch }}"
          CHANGED=""
          
          if git rev-parse --verify "origin/$BRANCH" >/dev/null 2>&1; then
            # Compare all changes from origin/branch to HEAD
            ORIGIN_SHA=$(git rev-parse "origin/$BRANCH")
            HEAD_SHA=$(git rev-parse HEAD)
            
            echo "   Origin SHA: $ORIGIN_SHA"
            echo "   HEAD SHA: $HEAD_SHA"
            
            if [[ "$ORIGIN_SHA" == "$HEAD_SHA" ]]; then
              # Same commit - check if frontend files exist (first deployment or redeployment)
              echo "üìå Same commit as origin/$BRANCH, checking if frontend files exist"
              if git ls-tree -r --name-only HEAD | grep -q '^frontend/'; then
                CHANGED="frontend/"
                echo "‚úÖ Frontend files found - will deploy"
              else
                echo "‚ö†Ô∏è  No frontend files found in current commit"
              fi
            else
              # Different commits - check for changes
              echo "üìå Different commits, checking for frontend changes"
              CHANGED=$(git diff --name-only "origin/$BRANCH" HEAD | grep '^frontend/' || true)
              if [[ -n "$CHANGED" ]]; then
                echo "‚úÖ Found frontend changes:"
                echo "$CHANGED" | sed 's/^/   - /'
              fi
            fi
          else
            # Branch doesn't exist on origin - deploy if frontend files exist
            echo "üìå New branch, checking if frontend files exist"
            git ls-tree -r --name-only HEAD | grep -q '^frontend/' && CHANGED="frontend/"
          fi
          
          if [[ -n "$CHANGED" ]]; then
            echo "‚úÖ Frontend changes detected"
            echo "has_changes=true" >> $GITHUB_OUTPUT
          else
            echo "‚è≠Ô∏è  No frontend changes detected"
            echo "has_changes=false" >> $GITHUB_OUTPUT
          fi

      - name: Set Docker Image Name and Tag
        if: steps.check_frontend.outputs.has_changes == 'true'
        run: |
          IMAGE_NAME="frontend-ui${{ needs.setup.outputs.image_suffix }}"
          TAG=$(date +%Y%m%d-%H%M%S)
          echo "IMAGE_NAME=$IMAGE_NAME" >> $GITHUB_ENV
          echo "TAG=$TAG" >> $GITHUB_ENV

      - name: Build and Push Docker Image
        if: steps.check_frontend.outputs.has_changes == 'true'
        run: |
          BASE_URL="${{ secrets.VITE_BASE_URL }}"
          if [[ "${{ needs.setup.outputs.env }}" == "development" ]]; then
            # Ensure BASE_URL ends with / before appending env_prefix
            [[ "$BASE_URL" != */ ]] && BASE_URL="${BASE_URL}/"
            # Append dev_ prefix
            BASE_URL="${BASE_URL}${{ needs.setup.outputs.env_prefix }}"
          fi
          
          docker build \
            --build-arg VITE_BASE_URL="$BASE_URL" \
            --build-arg VITE_SSO_URL="${{ secrets.VITE_SSO_URL }}" \
            -t asia-south1-docker.pkg.dev/training-project-419308/skill-matrix/${IMAGE_NAME}:${TAG} \
            ./frontend
          gcloud auth configure-docker asia-south1-docker.pkg.dev --quiet
          docker push asia-south1-docker.pkg.dev/training-project-419308/skill-matrix/${IMAGE_NAME}:${TAG}

      - name: Deploy Frontend to Cloud Run
        if: steps.check_frontend.outputs.has_changes == 'true'
        run: |
          CLOUD_RUN_SERVICE="${{ needs.setup.outputs.cloud_run_service }}"
          gcloud run deploy ${CLOUD_RUN_SERVICE} \
            --image=asia-south1-docker.pkg.dev/training-project-419308/skill-matrix/${IMAGE_NAME}:${TAG} \
            --platform=managed \
            --region=asia-south1 \
            --allow-unauthenticated \
            --quiet
          gcloud run services add-iam-policy-binding ${CLOUD_RUN_SERVICE} \
            --member="allUsers" \
            --role="roles/run.invoker" \
            --region=asia-south1 \
            --platform=managed \
            --quiet

  deploy-backend:
    runs-on: ubuntu-latest
    needs: setup
    if: needs.setup.outputs.deploy_backend == 'true'

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          repository: ${{ github.event.client_payload.repository || 'jktech-training/skill-matrix-V2' }}
          ref: ${{ github.event.client_payload.ref || 'main' }}
          token: ${{ secrets.PRIVATETOKENPULL }}
          fetch-depth: 0
          fetch-tags: true

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          credentials_json: '${{ secrets.GCP_SAKEY }}'

      - name: Set up Google Cloud SDK
        uses: google-github-actions/setup-gcloud@v2
        with:
          project_id: training-project-419308

      - name: Verify Required APIs
        run: |
          # Check if required APIs are enabled (don't try to enable - requires Service Usage API which needs manual activation)
          echo "üîç Verifying required APIs are enabled..."
          REQUIRED_APIS=("run.googleapis.com" "cloudbuild.googleapis.com" "cloudfunctions.googleapis.com" "iam.googleapis.com" "eventarc.googleapis.com")
          ALL_ENABLED=true
          
          for api in "${REQUIRED_APIS[@]}"; do
            if gcloud services list --enabled --filter="name:$api" --format="value(name)" 2>/dev/null | grep -q "$api"; then
              echo "   ‚úÖ $api is enabled"
            else
              echo "   ‚ö†Ô∏è  $api is not enabled"
              ALL_ENABLED=false
            fi
          done
          
          if [[ "$ALL_ENABLED" == "false" ]]; then
            echo "‚ö†Ô∏è  Some APIs may not be enabled. If deployment fails, enable them manually:"
            echo "   https://console.cloud.google.com/apis/library?project=training-project-419308"
          else
            echo "‚úÖ All required APIs are enabled"
          fi

      - name: Check for Changes in Backend
        id: check_backend
        run: |
          set -euo pipefail
          # Fetch full history and tags (ignore error if already unshallow)
          git fetch --unshallow --tags 2>/dev/null || git fetch --tags || true
          
          BRANCH="${{ needs.setup.outputs.branch }}"
          ENV="${{ needs.setup.outputs.env }}"
          REPO_ID="${{ needs.setup.outputs.repo }}"
          REPO_ID=$(echo "$REPO_ID" | sed 's/.*\///')
          DEPLOY_TAG="deployed-${REPO_ID}-${ENV}-backend"
          CHANGED=""
          LAST_DEPLOY_SHA=""
          
          # Try to find last successful deployment tag
          if git rev-parse --verify "$DEPLOY_TAG" >/dev/null 2>&1; then
            LAST_DEPLOY_SHA=$(git rev-parse "$DEPLOY_TAG")
            echo "üìå Found last deployment tag: $DEPLOY_TAG at commit $LAST_DEPLOY_SHA"
            # Compare from last deployment to HEAD
            CHANGED=$(git diff --name-only "$LAST_DEPLOY_SHA" HEAD | grep '^backend/' || true)
          elif git rev-parse --verify "origin/$BRANCH" >/dev/null 2>&1; then
            # No deployment tag found, compare with origin/branch
            echo "üìå No deployment tag found, comparing with origin/$BRANCH"
            ORIGIN_SHA=$(git rev-parse "origin/$BRANCH")
            HEAD_SHA=$(git rev-parse HEAD)
            
            echo "   Origin SHA: $ORIGIN_SHA"
            echo "   HEAD SHA: $HEAD_SHA"
            
            if [[ "$ORIGIN_SHA" == "$HEAD_SHA" ]]; then
              # Same commit - check if backend files exist (first deployment or redeployment)
              echo "üìå Same commit as origin/$BRANCH, checking if backend files exist"
              if git ls-tree -r --name-only HEAD | grep -q '^backend/'; then
                CHANGED="backend/"
                echo "‚úÖ Backend files found - will deploy"
              else
                echo "‚ö†Ô∏è  No backend files found in current commit"
              fi
            else
              # Different commits - check for changes
              echo "üìå Different commits, checking for backend changes"
              CHANGED=$(git diff --name-only "origin/$BRANCH" HEAD | grep '^backend/' || true)
              if [[ -n "$CHANGED" ]]; then
                echo "‚úÖ Found backend changes:"
                echo "$CHANGED" | sed 's/^/   - /'
              fi
            fi
          else
            # Branch doesn't exist on origin - deploy if backend files exist
            echo "üìå New branch, checking if backend files exist"
            git ls-tree -r --name-only HEAD | grep -q '^backend/' && CHANGED="backend/"
          fi
          
          if [[ -n "$CHANGED" ]]; then
            echo "‚úÖ Backend changes detected"
            echo "has_changes=true" >> $GITHUB_OUTPUT
            echo "last_deploy_sha=$LAST_DEPLOY_SHA" >> $GITHUB_OUTPUT
            echo "deploy_tag=$DEPLOY_TAG" >> $GITHUB_OUTPUT
            # Store in environment for use in deployment step
            echo "LAST_DEPLOY_SHA=$LAST_DEPLOY_SHA" >> $GITHUB_ENV
            echo "DEPLOY_TAG=$DEPLOY_TAG" >> $GITHUB_ENV
          else
            echo "‚è≠Ô∏è  No backend changes detected"
            echo "has_changes=false" >> $GITHUB_OUTPUT
          fi

      - name: Deploy Changed Backend Functions
        if: steps.check_backend.outputs.has_changes == 'true'
        env:
          LAST_DEPLOY_SHA: ${{ steps.check_backend.outputs.last_deploy_sha }}
          DEPLOY_TAG: ${{ steps.check_backend.outputs.deploy_tag }}
        run: |
          set -euo pipefail
          
          # Helper functions
          extract_entry_point() {
            local main_file="$1"
            local fn_folder="$2"
            
            # Convert folder name to expected function name pattern
            # Try to find function that matches folder name first
            if [[ -n "$fn_folder" ]]; then
              # Remove _v2 suffix from folder for matching
              folder_base="${fn_folder%_v2}"
              # Try to find function matching folder name (case-insensitive, with variations)
              matched=$(grep -iPo '^def\s+\K\w+(?=\s*\([^)]*request[^)]*\):)' "$main_file" 2>/dev/null | \
                grep -iE "(^${folder_base}$|^${fn_folder}$|${folder_base//Employee/employee}|${folder_base//[A-Z]/_&})" | head -n1)
              
              if [[ -n "$matched" ]]; then
                echo "$matched"
                return 0
              fi
            fi
            
            # Skip helper functions (cors_response, cors_handler, etc.)
            # Try to find main handler function (one with request parameter, excluding helpers)
            main_handler=$(grep -Po '^def\s+\K\w+(?=\s*\([^)]*request[^)]*\):)' "$main_file" 2>/dev/null | \
              grep -vE '^(cors_|helper_|util_|_cors)' | head -n1)
            
            if [[ -n "$main_handler" ]]; then
              echo "$main_handler"
              return 0
            fi
            
            # Fallback: get first function (excluding helpers)
            grep -E '^def\s+\w+\s*\(' "$main_file" 2>/dev/null | \
              grep -vE '^(def\s+(cors_|helper_|util_|_cors))' | \
              head -n1 | grep -oP 'def\s+\K\w+'
          }
          
          get_function_env_vars() {
            local fn_dir="$1"
            local base_vars="DB_HOST,DB_USER,DB_PASS,DB_NAME,DB_PORT,DB_SCHEMA"
            
            if [[ -d "$fn_dir" ]]; then
              detected_vars=$(find "$fn_dir" -name "*.py" -type f -exec grep -oE "os\.getenv\(['\"]([A-Z_][A-Z0-9_]*)['\"]" {} \; 2>/dev/null | \
                sed "s/os\.getenv(['\"]//" | sed "s/['\"]//" | sort -u | tr '\n' ',' | sed 's/,$//')
              
              [[ -n "$detected_vars" ]] && echo "üîç Auto-detected: $detected_vars"
              
              # Combine and deduplicate
              IFS=',' read -ra DETECTED <<< "$detected_vars"
              local combined="$base_vars"
              for var in "${DETECTED[@]}"; do
                var=$(echo "$var" | xargs)
                [[ "$base_vars" != *"$var"* ]] && [[ -n "$var" ]] && combined="${combined},${var}"
              done
              echo "$combined"
            else
              echo "$base_vars"
            fi
          }
          
          build_env_vars_file() {
            local required_vars="$1"
            local db_secrets="$2"
            local env_file="$3"
            
            [[ -z "$db_secrets" ]] && { echo "‚ùå ERROR: db_secrets is empty!"; return 1; }
            
            local temp_file=$(mktemp)
            echo "$db_secrets" | grep '=' > "$temp_file"
            
            echo "ENV: ${{ needs.setup.outputs.env }}" > "$env_file"
            
            # Add base DB variables
            local base_db_vars=("DB_HOST" "DB_USER" "DB_PASS" "DB_NAME" "DB_PORT" "DB_SCHEMA")
            for var in "${base_db_vars[@]}"; do
              var_line=$(grep "^${var}=" "$temp_file" | head -n1)
              [[ -n "$var_line" ]] && {
                var_value=$(echo "$var_line" | cut -d'=' -f2- | sed 's/\\/\\\\/g' | sed 's/"/\\"/g')
                [[ -n "$var_value" ]] && echo "${var}: \"${var_value}\"" >> "$env_file"
              }
            done
            
            # Add other detected variables
            IFS=',' read -ra REQUIRED <<< "$required_vars"
            for var in "${REQUIRED[@]}"; do
              var=$(echo "$var" | xargs)
              
              # Skip if already added
              skip=false
              for base_var in "${base_db_vars[@]}"; do
                [[ "$var" == "$base_var" ]] && skip=true && break
              done
              [[ "$skip" == "true" ]] && continue
              
              # Get from DB secret only
              [[ "$var" == "BUCKET_NAME" ]] && continue
              var_line=$(grep "^${var}=" "$temp_file" | head -n1)
              [[ -n "$var_line" ]] && {
                var_value=$(echo "$var_line" | cut -d'=' -f2- | sed 's/\\/\\\\/g' | sed 's/"/\\"/g')
                [[ -n "$var_value" ]] && echo "${var}: \"${var_value}\"" >> "$env_file"
              }
            done
            
            rm -f "$temp_file"
            echo "$env_file"
          }
          
          is_bucket_trigger() {
            local main_file="$1"
            local fn_dir="$2"
            grep -q "--trigger-bucket" "$main_file" 2>/dev/null && return 0
            [[ "$fn_dir" == *"CSVtoDB"* ]] || [[ "$fn_dir" == *"load"* ]] || [[ "$fn_dir" == *"split"* ]] && return 0
            [[ "$fn_dir" == *"uploadCv"* ]] || [[ "$fn_dir" == *"getMasterFile"* ]] && return 1
            grep -q "def.*event\|def.*data.*bucket\|def.*file.*event" "$main_file" 2>/dev/null && return 0
            return 1
          }
          
          set_iam_policy() {
            local function_name="$1"
            echo "üîê Setting IAM policy for public access..."
            
            # Wait for service to be available (usually ready within 5-10 seconds)
            for i in {1..5}; do
              if gcloud run services describe "$function_name" --region=asia-south1 --platform=managed --quiet >/dev/null 2>&1; then
                # Check if already configured
                if gcloud run services get-iam-policy "$function_name" \
                  --region=asia-south1 --platform=managed \
                  --format="value(bindings[].members)" 2>/dev/null | grep -q "allUsers"; then
                  echo "‚úÖ Public access already configured"
                  return 0
                fi
                
                # Set IAM policy using GitHub Actions service account
                if gcloud run services add-iam-policy-binding "$function_name" \
                  --region=asia-south1 \
                  --member="allUsers" \
                  --role="roles/run.invoker" \
                  --platform=managed \
                  --quiet 2>&1; then
                  echo "‚úÖ IAM policy set successfully"
                  return 0
                else
                  # Retry once after a short delay
                  sleep 1
                  if gcloud run services add-iam-policy-binding "$function_name" \
                    --region=asia-south1 \
                    --member="allUsers" \
                    --role="roles/run.invoker" \
                    --platform=managed \
                    --quiet 2>&1; then
                    echo "‚úÖ IAM policy set successfully (on retry)"
                    return 0
                  else
                    echo "‚ö†Ô∏è  IAM policy setting failed (function deployed successfully)"
                    return 0
                  fi
                fi
              fi
              [[ $i -lt 5 ]] && sleep 2
            done
            
            echo "‚ö†Ô∏è  Service not available - IAM policy setting skipped"
            return 0
          }
          
          # Main deployment loop
          DEPLOYED_COUNT=0
          SKIPPED_COUNT=0
          BRANCH="${{ needs.setup.outputs.branch }}"
          ENV_PREFIX="${{ needs.setup.outputs.env_prefix }}"
          REPO="${{ needs.setup.outputs.repo }}"
          
          # Determine DB secret
          if [[ "$REPO" == "jktech-training/skill-matrix" ]] && [[ "$BRANCH" == "main" ]]; then
            DB_SECRET="${{ secrets.DB_PROD }}"
          elif [[ "$REPO" == "jktech-training/skill-matrix" ]]; then
            DB_SECRET="${{ secrets.DB_DEV }}"
          else
            DB_SECRET="${{ secrets.DB_DEV_V2 }}"
          fi
          
          [[ -z "$DB_SECRET" ]] && { echo "‚ùå ERROR: DB secret is empty!"; exit 1; }
          DB_SECRET=$(echo "$DB_SECRET" | grep -v '^[[:space:]]*$' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
          
          # First pass: Collect functions to deploy
          echo "üîç Detecting functions to deploy..."
          declare -a FUNCTIONS_TO_DEPLOY=()
          declare -a FUNCTION_NAMES=()
          declare -a FUNCTION_DIRS=()
          declare -a FUNCTION_ENTRY_POINTS=()
          declare -a FUNCTION_FOLDERS=()
          
          while IFS= read -r MAIN_FILE; do
            fn_dir=$(dirname "$MAIN_FILE")
            fn_folder=$(basename "$fn_dir")
            
            # Check for changes - compare from last deployment or origin/branch to HEAD
            CHANGED_FILES=""
            if [[ -n "$LAST_DEPLOY_SHA" ]] && git rev-parse --verify "$LAST_DEPLOY_SHA" >/dev/null 2>&1; then
              CHANGED_FILES=$(git diff --name-only "$LAST_DEPLOY_SHA" HEAD -- "$fn_dir" || echo "")
            elif git rev-parse --verify "origin/$BRANCH" >/dev/null 2>&1; then
              CHANGED_FILES=$(git diff --name-only "origin/$BRANCH" HEAD -- "$fn_dir" || echo "")
            fi
            
            [[ -z "$CHANGED_FILES" ]] && ! git ls-tree -r --name-only HEAD -- "$fn_dir" | grep -q . && {
              echo "‚è≠Ô∏è  Skipping $fn_folder (no changes)"
              ((SKIPPED_COUNT++)) || true
              continue
            }
            
            # Extract entry point (pass folder name to help match correct function)
            ENTRY_POINT=$(extract_entry_point "$MAIN_FILE" "$fn_folder")
            [[ -z "$ENTRY_POINT" ]] && {
              echo "‚ö†Ô∏è  No entry point in $MAIN_FILE. Skipping..."
              ((SKIPPED_COUNT++)) || true
              continue
            }
            
            # Determine function name
            if [[ "$fn_folder" == *_v2 ]]; then
              [[ "$ENTRY_POINT" == *_v2 ]] && FUNCTION_NAME="${ENV_PREFIX}${ENTRY_POINT}" || \
                FUNCTION_NAME="${ENV_PREFIX}${ENTRY_POINT}_v2"
            else
              FUNCTION_NAME="${ENV_PREFIX}${ENTRY_POINT}"
            fi
            
            # Add to arrays
            FUNCTIONS_TO_DEPLOY+=("$MAIN_FILE")
            FUNCTION_NAMES+=("$FUNCTION_NAME")
            FUNCTION_DIRS+=("$fn_dir")
            FUNCTION_ENTRY_POINTS+=("$ENTRY_POINT")
            FUNCTION_FOLDERS+=("$fn_folder")
          done < <(find backend -type f -name "main.py")
          
          # Display detected functions
          TOTAL_FUNCTIONS=${#FUNCTIONS_TO_DEPLOY[@]}
          if [[ $TOTAL_FUNCTIONS -eq 0 ]]; then
            echo "‚ÑπÔ∏è  No functions detected for deployment"
            exit 0
          fi
          
          echo ""
          echo "üìã Detected $TOTAL_FUNCTIONS function(s) to deploy:"
          for i in "${!FUNCTIONS_TO_DEPLOY[@]}"; do
            echo "   $((i+1)). ${FUNCTION_NAMES[$i]} (${FUNCTION_FOLDERS[$i]})"
          done
          echo ""
          
          # Second pass: Deploy functions with progress
          for i in "${!FUNCTIONS_TO_DEPLOY[@]}"; do
            MAIN_FILE="${FUNCTIONS_TO_DEPLOY[$i]}"
            FUNCTION_NAME="${FUNCTION_NAMES[$i]}"
            fn_dir="${FUNCTION_DIRS[$i]}"
            ENTRY_POINT="${FUNCTION_ENTRY_POINTS[$i]}"
            fn_folder="${FUNCTION_FOLDERS[$i]}"
            CURRENT_NUM=$((i+1))
            
            echo "üöÄ Deploying $CURRENT_NUM/$TOTAL_FUNCTIONS: $FUNCTION_NAME (${fn_folder})"
            
            # Build environment variables file
            REQUIRED_ENV_VARS=$(get_function_env_vars "$fn_dir")
            ENV_VARS_FILE=$(mktemp)
            
            build_env_vars_file "$REQUIRED_ENV_VARS" "$DB_SECRET" "$ENV_VARS_FILE" || {
              echo "‚ùå Failed to build env vars file"
              exit 1
            }
            
            # Verify DB credentials
            grep -q "^DB_HOST:" "$ENV_VARS_FILE" && grep -q "^DB_USER:" "$ENV_VARS_FILE" && \
              grep -q "^DB_PASS:" "$ENV_VARS_FILE" && grep -q "^DB_NAME:" "$ENV_VARS_FILE" || {
              echo "‚ùå ERROR: DB credentials missing!"
              cat "$ENV_VARS_FILE"
              rm -f "$ENV_VARS_FILE"
              exit 1
            }
            
            # Add BUCKET_NAME if needed
            [[ "$REQUIRED_ENV_VARS" == *"BUCKET_NAME"* ]] && \
              echo "BUCKET_NAME: \"${{ needs.setup.outputs.bucket_name }}\"" >> "$ENV_VARS_FILE"
            
            # Verify OPENAI_API_KEY if required
            [[ "$REQUIRED_ENV_VARS" == *"OPENAI_API_KEY"* ]] && \
              ! grep -q "^OPENAI_API_KEY:" "$ENV_VARS_FILE" && {
              echo "‚ùå ERROR: OPENAI_API_KEY required but not found in DB secret!"
              echo "   Please ensure OPENAI_API_KEY is included in your DB secret (DB_PROD, DB_DEV, or DB_DEV_V2)."
              rm -f "$ENV_VARS_FILE"
              exit 1
            }
            
            # Deploy function
            if is_bucket_trigger "$MAIN_FILE" "$fn_dir"; then
              gcloud functions deploy "$FUNCTION_NAME" \
                --runtime python310 --trigger-bucket ${{ needs.setup.outputs.bucket_name }} \
                --entry-point "$ENTRY_POINT" --source "$fn_dir" \
                --service-account training-project-419308@appspot.gserviceaccount.com \
                --region asia-south1 --gen2 --memory 512Mi --timeout 540s \
                --env-vars-file "$ENV_VARS_FILE" --quiet && {
                echo "‚úÖ [$CURRENT_NUM/$TOTAL_FUNCTIONS] Deployed: $FUNCTION_NAME (bucket trigger)"
                ((DEPLOYED_COUNT++)) || true
              } || {
                echo "‚ùå [$CURRENT_NUM/$TOTAL_FUNCTIONS] Failed: $FUNCTION_NAME"
                ((SKIPPED_COUNT++)) || true
              }
            else
              gcloud functions deploy "$FUNCTION_NAME" \
                --runtime python310 --trigger-http --entry-point "$ENTRY_POINT" \
                --source "$fn_dir" --service-account training-project-419308@appspot.gserviceaccount.com \
                --allow-unauthenticated --gen2 --region asia-south1 \
                --env-vars-file "$ENV_VARS_FILE" --quiet && {
                set_iam_policy "$FUNCTION_NAME" || true
                echo "‚úÖ [$CURRENT_NUM/$TOTAL_FUNCTIONS] Deployed: $FUNCTION_NAME (HTTP trigger)"
                ((DEPLOYED_COUNT++)) || true
              } || {
                echo "‚ùå [$CURRENT_NUM/$TOTAL_FUNCTIONS] Failed: $FUNCTION_NAME"
                ((SKIPPED_COUNT++)) || true
              }
            fi
            
            rm -f "$ENV_VARS_FILE"
          done < <(find backend -type f -name "main.py")
          
          echo ""
          echo "üìä Deployment Summary:"
          echo "   Environment: ${{ needs.setup.outputs.env }}"
          echo "   Deployed: $DEPLOYED_COUNT functions"
          echo "   Skipped: $SKIPPED_COUNT functions"
          
          # Create/update deployment tag if deployment was successful
          if [[ $DEPLOYED_COUNT -gt 0 ]] && [[ -n "$DEPLOY_TAG" ]]; then
            CURRENT_SHA=$(git rev-parse HEAD)
            echo "üè∑Ô∏è  Creating deployment tag: $DEPLOY_TAG at commit $CURRENT_SHA"
            git config user.name "GitHub Actions" || true
            git config user.email "actions@github.com" || true
            git tag -f "$DEPLOY_TAG" "$CURRENT_SHA" -m "Backend deployment successful - ${{ needs.setup.outputs.env }} - $(date +%Y-%m-%d\ %H:%M:%S)" || true
            git push origin "$DEPLOY_TAG" --force || echo "‚ö†Ô∏è  Could not push tag (may need write permissions)"
          fi
          
          [[ $DEPLOYED_COUNT -eq 0 ]] && [[ $SKIPPED_COUNT -gt 0 ]] && exit 1
